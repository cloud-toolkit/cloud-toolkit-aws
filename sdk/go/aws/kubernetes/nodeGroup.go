// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package kubernetes

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws/ec2"
	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws/eks"
	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws/iam"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// NodeGroup is a component that deploy a Node Group for a Kubernetes cluster.
type NodeGroup struct {
	pulumi.ResourceState

	// The EC2 Launch Template used to provision nodes.
	LaunchTemplate ec2.LaunchTemplateOutput `pulumi:"launchTemplate"`
	// The EKS Node Group.
	NodeGroup eks.NodeGroupOutput `pulumi:"nodeGroup"`
	// The IAM Role assumed by the EKS Nodes.
	Role iam.RoleOutput `pulumi:"role"`
	// The list of IAM Role Policy Attachment used to attach IAM Roles to the EKS Node Group.
	RolePolicyAttachments iam.RolePolicyAttachmentArrayOutput `pulumi:"rolePolicyAttachments"`
}

// NewNodeGroup registers a new resource with the given unique name, arguments, and options.
func NewNodeGroup(ctx *pulumi.Context,
	name string, args *NodeGroupArgs, opts ...pulumi.ResourceOption) (*NodeGroup, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterCA == nil {
		return nil, errors.New("invalid value for required argument 'ClusterCA'")
	}
	if args.ClusterEndpoint == nil {
		return nil, errors.New("invalid value for required argument 'ClusterEndpoint'")
	}
	if args.ClusterName == nil {
		return nil, errors.New("invalid value for required argument 'ClusterName'")
	}
	if args.ClusterVersion == nil {
		return nil, errors.New("invalid value for required argument 'ClusterVersion'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	if args.SubnetIds == nil {
		return nil, errors.New("invalid value for required argument 'SubnetIds'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource NodeGroup
	err := ctx.RegisterRemoteComponentResource("cloud-toolkit-aws:kubernetes:NodeGroup", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type nodeGroupArgs struct {
	// The CA used by the Kubernetes cluster.
	ClusterCA string `pulumi:"clusterCA"`
	// The Kubernetes cluster endpoint.
	ClusterEndpoint string `pulumi:"clusterEndpoint"`
	// The Kubernetes cluster name.
	ClusterName string `pulumi:"clusterName"`
	// The Kubernetes cluster version.
	ClusterVersion string `pulumi:"clusterVersion"`
	// The aws instance type to use for the nodes. Defaults to "t3.medium".
	InstanceType *string `pulumi:"instanceType"`
	// The maxium number of nodes running in the node group. Defaults to 2.
	MaxCount *float64 `pulumi:"maxCount"`
	// The maximum number of nodes unavailable at once during a version update. Defaults to 1.
	MaxUnavailable *float64 `pulumi:"maxUnavailable"`
	// The minimum number of nodes running in the node group. Defaults to 1.
	MinCount *float64 `pulumi:"minCount"`
	// The name that identies the resource.
	Name string `pulumi:"name"`
	// The list of subnets ids where the nodes will be deployed.
	SubnetIds []string `pulumi:"subnetIds"`
}

// The set of arguments for constructing a NodeGroup resource.
type NodeGroupArgs struct {
	// The CA used by the Kubernetes cluster.
	ClusterCA pulumi.StringInput
	// The Kubernetes cluster endpoint.
	ClusterEndpoint pulumi.StringInput
	// The Kubernetes cluster name.
	ClusterName pulumi.StringInput
	// The Kubernetes cluster version.
	ClusterVersion pulumi.StringInput
	// The aws instance type to use for the nodes. Defaults to "t3.medium".
	InstanceType pulumi.StringPtrInput
	// The maxium number of nodes running in the node group. Defaults to 2.
	MaxCount pulumi.Float64PtrInput
	// The maximum number of nodes unavailable at once during a version update. Defaults to 1.
	MaxUnavailable pulumi.Float64PtrInput
	// The minimum number of nodes running in the node group. Defaults to 1.
	MinCount pulumi.Float64PtrInput
	// The name that identies the resource.
	Name pulumi.StringInput
	// The list of subnets ids where the nodes will be deployed.
	SubnetIds pulumi.StringArrayInput
}

func (NodeGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*nodeGroupArgs)(nil)).Elem()
}

type NodeGroupInput interface {
	pulumi.Input

	ToNodeGroupOutput() NodeGroupOutput
	ToNodeGroupOutputWithContext(ctx context.Context) NodeGroupOutput
}

func (*NodeGroup) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeGroup)(nil)).Elem()
}

func (i *NodeGroup) ToNodeGroupOutput() NodeGroupOutput {
	return i.ToNodeGroupOutputWithContext(context.Background())
}

func (i *NodeGroup) ToNodeGroupOutputWithContext(ctx context.Context) NodeGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeGroupOutput)
}

// NodeGroupArrayInput is an input type that accepts NodeGroupArray and NodeGroupArrayOutput values.
// You can construct a concrete instance of `NodeGroupArrayInput` via:
//
//	NodeGroupArray{ NodeGroupArgs{...} }
type NodeGroupArrayInput interface {
	pulumi.Input

	ToNodeGroupArrayOutput() NodeGroupArrayOutput
	ToNodeGroupArrayOutputWithContext(context.Context) NodeGroupArrayOutput
}

type NodeGroupArray []NodeGroupInput

func (NodeGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NodeGroup)(nil)).Elem()
}

func (i NodeGroupArray) ToNodeGroupArrayOutput() NodeGroupArrayOutput {
	return i.ToNodeGroupArrayOutputWithContext(context.Background())
}

func (i NodeGroupArray) ToNodeGroupArrayOutputWithContext(ctx context.Context) NodeGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeGroupArrayOutput)
}

// NodeGroupMapInput is an input type that accepts NodeGroupMap and NodeGroupMapOutput values.
// You can construct a concrete instance of `NodeGroupMapInput` via:
//
//	NodeGroupMap{ "key": NodeGroupArgs{...} }
type NodeGroupMapInput interface {
	pulumi.Input

	ToNodeGroupMapOutput() NodeGroupMapOutput
	ToNodeGroupMapOutputWithContext(context.Context) NodeGroupMapOutput
}

type NodeGroupMap map[string]NodeGroupInput

func (NodeGroupMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NodeGroup)(nil)).Elem()
}

func (i NodeGroupMap) ToNodeGroupMapOutput() NodeGroupMapOutput {
	return i.ToNodeGroupMapOutputWithContext(context.Background())
}

func (i NodeGroupMap) ToNodeGroupMapOutputWithContext(ctx context.Context) NodeGroupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeGroupMapOutput)
}

type NodeGroupOutput struct{ *pulumi.OutputState }

func (NodeGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeGroup)(nil)).Elem()
}

func (o NodeGroupOutput) ToNodeGroupOutput() NodeGroupOutput {
	return o
}

func (o NodeGroupOutput) ToNodeGroupOutputWithContext(ctx context.Context) NodeGroupOutput {
	return o
}

// The EC2 Launch Template used to provision nodes.
func (o NodeGroupOutput) LaunchTemplate() ec2.LaunchTemplateOutput {
	return o.ApplyT(func(v *NodeGroup) ec2.LaunchTemplateOutput { return v.LaunchTemplate }).(ec2.LaunchTemplateOutput)
}

// The EKS Node Group.
func (o NodeGroupOutput) NodeGroup() eks.NodeGroupOutput {
	return o.ApplyT(func(v *NodeGroup) eks.NodeGroupOutput { return v.NodeGroup }).(eks.NodeGroupOutput)
}

// The IAM Role assumed by the EKS Nodes.
func (o NodeGroupOutput) Role() iam.RoleOutput {
	return o.ApplyT(func(v *NodeGroup) iam.RoleOutput { return v.Role }).(iam.RoleOutput)
}

// The list of IAM Role Policy Attachment used to attach IAM Roles to the EKS Node Group.
func (o NodeGroupOutput) RolePolicyAttachments() iam.RolePolicyAttachmentArrayOutput {
	return o.ApplyT(func(v *NodeGroup) iam.RolePolicyAttachmentArrayOutput { return v.RolePolicyAttachments }).(iam.RolePolicyAttachmentArrayOutput)
}

type NodeGroupArrayOutput struct{ *pulumi.OutputState }

func (NodeGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NodeGroup)(nil)).Elem()
}

func (o NodeGroupArrayOutput) ToNodeGroupArrayOutput() NodeGroupArrayOutput {
	return o
}

func (o NodeGroupArrayOutput) ToNodeGroupArrayOutputWithContext(ctx context.Context) NodeGroupArrayOutput {
	return o
}

func (o NodeGroupArrayOutput) Index(i pulumi.IntInput) NodeGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NodeGroup {
		return vs[0].([]*NodeGroup)[vs[1].(int)]
	}).(NodeGroupOutput)
}

type NodeGroupMapOutput struct{ *pulumi.OutputState }

func (NodeGroupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NodeGroup)(nil)).Elem()
}

func (o NodeGroupMapOutput) ToNodeGroupMapOutput() NodeGroupMapOutput {
	return o
}

func (o NodeGroupMapOutput) ToNodeGroupMapOutputWithContext(ctx context.Context) NodeGroupMapOutput {
	return o
}

func (o NodeGroupMapOutput) MapIndex(k pulumi.StringInput) NodeGroupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NodeGroup {
		return vs[0].(map[string]*NodeGroup)[vs[1].(string)]
	}).(NodeGroupOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NodeGroupInput)(nil)).Elem(), &NodeGroup{})
	pulumi.RegisterInputType(reflect.TypeOf((*NodeGroupArrayInput)(nil)).Elem(), NodeGroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NodeGroupMapInput)(nil)).Elem(), NodeGroupMap{})
	pulumi.RegisterOutputType(NodeGroupOutput{})
	pulumi.RegisterOutputType(NodeGroupArrayOutput{})
	pulumi.RegisterOutputType(NodeGroupMapOutput{})
}
